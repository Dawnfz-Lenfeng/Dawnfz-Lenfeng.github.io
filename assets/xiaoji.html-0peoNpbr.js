import{_ as r,c as e,a as l,e as t,b as i,o as s,r as u}from"./app-Bs44IHSh.js";const p={},m={href:"https://github.com/Dawnfz-Lenfeng/mylang",target:"_blank",rel:"noopener noreferrer"};function d(f,n){const o=u("ExternalLinkIcon");return s(),e("div",null,[n[13]||(n[13]=l("h1",{id:"小记",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#小记"},[l("span",null,"小记")])],-1)),n[14]||(n[14]=l("p",null,"这个暑假写了不少小玩意。第一个小玩意是人大教室预约系统，打算在大四毕业的时候开源。这个项目说实话比较 trivial，接近于现实工作里的螺丝钉工作。浅浅地逆向了一下学校后端的 API，加 AI 辅助的前端设计，基本就能完成一个可以用的应用。",-1)),n[15]||(n[15]=l("p",null,"80% 的应用大概也是如此流程。从大创、个人博客到这个项目，已经基本尝试过好几个类似传统开发类工作。说实话这种工作其实有点意思，但是想到如果我后半生都要在写 CRUD 中度过，还是会感觉到单调，毕竟前人框架搭的已经足够好。",-1)),n[16]||(n[16]=l("hr",null,null,-1)),n[17]||(n[17]=l("p",null,"第二个项目是一直想写的解释器。记得去年暑假的时候就想用 Rust 写自己的编译器，一方面可以接触到编译原理，说不定之后有机会能参与到编译器的工作，另一方面借此机会学习到 Rust —— 多学习一门语言总是好的，能体悟到语言中优雅的设计。这次实现了基于字节码的解释器，说不定再花点时间跟 LLVM 对接可以变成编译器（顺便也可以学学 LLVM)。",-1)),l("p",null,[n[1]||(n[1]=t("很高兴大概花了 2 个星期的时间实现了一个勉强能用的 Version：")),l("a",m,[n[0]||(n[0]=t("Dawnfz-Lenfeng/mylang: Programming language interpreter written in Rust")),i(o)]),n[2]||(n[2]=t("，手写了前端 ")),n[3]||(n[3]=l("code",null,"lexer",-1)),n[4]||(n[4]=t("、")),n[5]||(n[5]=l("code",null,"parser",-1)),n[6]||(n[6]=t("（感觉比较简单），实现了很简陋的虚拟机 ")),n[7]||(n[7]=l("code",null,"VM",-1)),n[8]||(n[8]=t("。没有继续写下去主要是因为 ")),n[9]||(n[9]=l("code",null,"Value",-1)),n[10]||(n[10]=t(" 的设计部分——主流解释器基本都倾向于使用 ")),n[11]||(n[11]=l("code",null,"union",-1)),n[12]||(n[12]=t(" 联合体，这里简单用 Rust 枚举替代了，导致优化、GC等都不太好做，因此也没实现面向对象。"))]),n[18]||(n[18]=l("p",null,"其实很想有自己的解释器设计。因为就目前设计来说市面上的解释器实现并不算优雅。Python all in Object 从接口层面非常优雅易理解，但是后端不好优化。Js V8 引擎非常厉害，但是建立在原始类型 primitive type + 对象 Object的基础上——这样的设计个人觉得有些割裂（譬如每一个原始类型还要有自己的对象实现，不如 python 优雅）。像 Lua 设计倒是非常不错，小而精，确实厉害。可惜解释器没有像 cpp 这种四海皆准的 Silver Bullet，感觉上限基本如此了。",-1)),n[19]||(n[19]=l("p",null,[t("优雅的设计个人认为有一个典范是Rust。其枚举集成了传统枚举和联合体，同时顺便增强了模式匹配。另外错误处理和返回值相统一的思路比 Go 做的更好更彻底，区分出了 "),l("code",null,"Option"),t(" 和 "),l("code",null,"Result"),t(" ，从而形成的优雅的错误处理生态，几乎是现代语言设计的范本！简直是心中近乎完美的设计，写起来确实顺手，期待之后能用 Rust 写更多的小工具。")],-1)),n[20]||(n[20]=l("p",null,"如今现代语言对类型的要求越来越高，比如衍生出了 Typescript，说不定自己写一个强类型+高性能的解释器？不过按照目前的场景（前端应用侧 JS +机器学习 python），感觉解释器不太好向后发展了。尤其是 LLVM （简单了解后感觉真是伟大的设计）出现后，写一个编译性的语言说不定比解释性语言反而更方便（无需后端）。",-1)),n[21]||(n[21]=l("hr",null,null,-1)),n[22]||(n[22]=l("p",null,"最后，比较头疼的是路线选择问题。显而易见的是我对 AI 的兴趣乏善可陈。我喜欢系统级别的设计，我对优雅设计有着一种本能的偏好和追求。AI 是一条很多人选择的捷径，但是一方面我觉得算法工作我并不感兴趣（需要几乎不讲道理的 insight 和许多的经验主义），个人并不觉得优雅。另一方面 AI 应用侧感觉还是 CRUD 的另一种延续（Agent 或许成为新的前后端开发设计的替代品？）",-1)),n[23]||(n[23]=l("p",null,"传统的系统方向往往艰深，再加上我确实底层理论不太够。不知今后走向何方，期待自己升学后能学习到更多知识，开阔更多眼界，说不定能写出自己的框架？也说不定会重新拥抱 AI。",-1))])}const L=r(p,[["render",d],["__file","xiaoji.html.vue"]]),x=JSON.parse('{"path":"/blogs/xiaoji.html","title":"小记","lang":"zh-CN","frontmatter":{"date":"2025-08-14T00:00:00.000Z"},"headers":[],"git":{"createdTime":1755185239000,"updatedTime":1755185239000,"contributors":[{"name":"Dawnfz-Lenfeng","email":"2912706234@qq.com","commits":1}]},"filePathRelative":"blogs/小记.md"}');export{L as comp,x as data};
